################################################################################
# Utilities and wrappers for plotting heatmaps
################################################################################
#' plotCorPhm
#' 
#' Plot a correlation matrix as heatmap. Wraps around \code{pheatmap}. Note that no clustering will be performed if not supplied with an appropriate clustering dendrogram
#' @param cc        a correlation matrix (as returned by \code{cor()})
#' @param clustDend a clustering dendrogram to be used. Set to \code{NULL} to disable clustering dendrogram
#' @param sampleAnnot a data.frame containing sample information to color by (corrsponds to \code{annotation_row} and \code{annotation_col} parameters of \code{pheatmap()})
#' @param color     see \code{?pheatmap} for details
#' @param breaks    see \code{?pheatmap} for details. In this wrapper, the default value corresponds to splitting color across the full range of correlation coefficients [-1,1]
#' @param border_color     see \code{?pheatmap} for details
#' @param ...       parameters passed on to \code{pheatmap()}
#' @return invisibly the result of a call to \code{pheatmap()}
#' @author Fabian Mueller
#' @export 
plotCorPhm <- function(
		cc,
		clustDend=NULL,
		sampleAnnot=NA,
		color=colorRampPalette(rev(brewer.pal(n=11, name = "RdBu")))(100),
		breaks=seq(-1-1e-6, 1+1e-6, length.out=length(color)+1),
		border_color=NA,
		...){
	require(pheatmap)
	clustr <- FALSE
	if (!is.null(clustDend)){
		if (!is.element("dendrogram", class(clustDend))){
			stop("clustDend must be a dendrogram")
		}
		clustr <- as.hclust(clustDend)
	}

	pheatmap(cc, color=color, breaks=breaks, border_color=border_color, annotation_row=sampleAnnot, annotation_col=sampleAnnot, cluster_rows=clustr, cluster_cols=clustr, ...)
}
# todo: check out display_numbers parameter for pheatmap (https://github.com/raivokolde/pheatmap/issues/24)

#' diagDivHeatmap
#' 
#' Plot a diagonally divided heatmap u
#' @param ml        the first value matrix (the left-lower diagonal matrix will be in the result)
#' @param mr        the first value matrix (the right-upper diagonal matrix will be in the result)
#' @param col.l     color scheme for the left-lower diagonal matrix. Should be generated by \code{circlize::colorRamp2}.
#'                  If \code{NULL} a default color scheme witll be used.
#' @param col.r     color scheme for the upper-right diagonal matrix. Should be generated by \code{circlize::colorRamp2}.
#'                  If \code{NULL} a default color scheme witll be used.
#' @param name.l    Name for the lower-left submatrix
#' @param name.r    Name for the upper-right submatrix
#' @param cluster   logical or clustering object. will be passed to the \code{cluster_rows} and \code{cluster_columns} arguments of \code{Heatmap}
#' @param cell.val.text  logical indicating whether the cells value should be added as text
#' @param cell.val.text.round if the cell value is numeric, the number of digits to which the cell text is rounded
#' @param ...       parameters passed on to \code{ComplexHeatmap::Heatmap}
#' @return a \code{ComplexHeatmap::Heatmap} object containing the heatmap
#' @author Fabian Mueller
#' @export
#' @examples
#' m1 <- matrix(rnorm(100, mean=0), ncol=10)
#' m2 <- matrix(rnorm(100, mean=2), ncol=10)
#' rownames(m1) <- rownames(m2) <- colnames(m1) <- colnames(m2) <- paste0("Idx", 1:10)
#' diagDivHeatmap(m1, m2)
#' diagDivHeatmap(m1, m2, cell.val.text=TRUE, cell.val.text.round=3)
#' cres <- as.hclust(muRtools::getClusteringDendrogram(m1, distMethod="euclidean", linkMethod="ward.D", corMethod="pearson"))
#' diagDivHeatmap(m1, m2, cluster=cres, cell.val.text=TRUE, cell.val.text.round=2)
diagDivHeatmap <- function(ml, mr, col.l=NULL, col.r=NULL, name.l="Lower left", name.r="Upper right", cluster=FALSE, cell.val.text=FALSE, cell.val.text.round=2, ...){
	require(ComplexHeatmap)
	if (nrow(ml)!=nrow(mr)) stop("Numbers of rows of the two matrices must match")
	if (ncol(ml)!=ncol(mr)) stop("Numbers of columns of the two matrices must match")
	if (nrow(ml)!=ncol(ml)) stop("Matrices must be quadratic")
	if (!is.element(class(cluster), c("hclust", "logical"))) stop("parameter 'cluster' must be hclust or logical")
	if (is.logical(cluster) && cluster) stop("parameter 'cluster' currently can not be set to TRUE (would mess up the ordering)")

	if (is.null(col.l)){
		col.l <- circlize::colorRamp2(seq(min(ml, na.rm=TRUE), max(ml, na.rm=TRUE), length.out=9), rev(colpal.cont(9, "cb.YlOrRd")))
	}
	if (is.null(col.r)){
		col.r <- circlize::colorRamp2(seq(min(mr, na.rm=TRUE), max(mr, na.rm=TRUE), length.out=9), colpal.cont(9, "viridis"))
	}

	mc <- ml
	mc[upper.tri(mc)] <- mr[upper.tri(mr)]

	cell.text.fun <- identity
	if (is.numeric(mc)) cell.text.fun <- function(x){sprintf(paste0("%.", cell.val.text.round, "f"), x)}

	idxMap <- 1:nrow(ml)
	if (class(cluster)=="hclust") idxMap <- order(cluster$order)

	dotArgs <- list(...)
	res <- Heatmap(ml,
		col=col.l,
		cluster_rows=cluster, cluster_columns=cluster,
		rect_gp=gpar(type="none"),
		cell_fun = function(j, i, x, y, width, height, fill) {
			grid.rect(x=x, y=y, width=width, height=height, gp=gpar(col=NA, fill="grey"))
			if (idxMap[i] == idxMap[j]) {
				grid.text(rownames(ml)[i], x=x, y=y)
			} else if(idxMap[i] > idxMap[j]) {
				if (!is.na(ml[i, j])){
					grid.rect(x=x, y=y, width=width, height=height, gp=gpar(col=NA, fill=col.l(ml[i, j])))
					if (cell.val.text){
						grid.text(cell.text.fun(ml[i, j]), x, y)
					}
				}
			} else {
				if (!is.na(mr[i, j])) {
					grid.rect(x=x, y=y, width=width, height=height, gp=gpar(col=NA, fill=col.r(mr[i, j])))
					if (cell.val.text){
						grid.text(cell.text.fun(mr[i, j]), x, y)
					}
				}
			}
		},
		name=name.l,
		...
	)
	# dummy heatmap for color legend
	dummyM <- matrix(rep(NA, length.out=nrow(mr)), nrow=nrow(mr), ncol=1)
	rownames(dummyM) <- rownames(mr)
	dummyHm <- Heatmap(dummyM, col=col.r, cluster_rows=cluster, cluster_columns=FALSE, width=unit(0, "mm"), name=name.r)
	return(res + dummyHm)
}

#' diagDivCellHeatmap
#' 
#' Plot a heatmap in which each cell is subdivided into a lower-left and upper-right triangle representing
#' the values of two matrices
#' @param ml        the first value matrix (will be the left-lower diagonal in the cells of the resulting heatmap)
#' @param mr        the second value matrix (will be the right-upper diagonal in the cells of the resulting heatmap)
#' @param col.l     color scheme for the left-lower diagonal matrix. Should be generated by \code{circlize::colorRamp2}.
#'                  If \code{NULL} a default color scheme witll be used.
#' @param col.r     color scheme for the upper-right diagonal matrix. Should be generated by \code{circlize::colorRamp2}.
#'                  If \code{NULL} a default color scheme witll be used.
#' @param name.l    Name for the lower-left submatrix
#' @param name.r    Name for the upper-right submatrix
#' @param ...       parameters passed on to \code{ComplexHeatmap::Heatmap}
#' @return a \code{ComplexHeatmap::Heatmap} object containing the heatmap
#' @author Fabian Mueller
#' @export
#' @examples
#' m1 <- matrix(rnorm(100, mean=0), ncol=10)
#' m2 <- matrix(rnorm(100, mean=2), ncol=10)
#' rownames(m1) <- rownames(m2) <- colnames(m1) <- colnames(m2) <- paste0("Idx", 1:10)
#' diagDivCellHeatmap(m1, m2, cluster_rows=FALSE, cluster_columns=FALSE)
#' cres <- as.hclust(muRtools::getClusteringDendrogram(m1, distMethod="euclidean", linkMethod="ward.D", corMethod="pearson"))
#' diagDivCellHeatmap(m1, m2, cluster_rows=cres, cluster_columns=cres)
diagDivCellHeatmap <- function(ml, mr, col.l=NULL, col.r=NULL, name.l="Lower left", name.r="Upper right", ...){
	require(ComplexHeatmap)
	if (nrow(ml)!=nrow(mr)) stop("Numbers of rows of the two matrices must match")
	if (ncol(ml)!=ncol(mr)) stop("Numbers of columns of the two matrices must match")

	if (is.null(col.l)){
		col.l <- circlize::colorRamp2(seq(min(ml, na.rm=TRUE), max(ml, na.rm=TRUE), length.out=9), rev(colpal.cont(9, "cb.YlOrRd")))
	}
	if (is.null(col.r)){
		col.r <- circlize::colorRamp2(seq(min(mr, na.rm=TRUE), max(mr, na.rm=TRUE), length.out=9), colpal.cont(9, "viridis"))
	}

	res <- Heatmap(ml,
		col=col.l, rect_gp=gpar(type="none"),
		cell_fun = function(j, i, x, y, width, height, fill) {
			# grid.rect(x=x, y=y, width=width, height=height, gp=gpar(col="grey", fill="grey"))
			grid.polygon(
				x=unit.c(x-0.5*width, x+0.5*width, x-0.5*width),
				y=unit.c(y-0.5*width, y-0.5*width, y+0.5*width),
				gp=gpar(col=NA, fill=col.l(ml[i, j]))
			)
			grid.polygon(
				x=unit.c(x+0.5*width, x-0.5*width, x+0.5*width),
				y=unit.c(y+0.5*width, y+0.5*width, y-0.5*width),
				gp=gpar(col=NA, fill=col.r(mr[i, j]))
			)
		},
		name=name.l,
		...
	)
	# dummy heatmap for color legend
	dummyM <- matrix(rep(NA, length.out=nrow(mr)), nrow=nrow(ml), ncol=1)
	rownames(dummyM) <- rownames(ml)
	dummyHm <- Heatmap(dummyM, col=col.r, width=unit(0, "mm"), name=name.r)

	return(res + dummyHm)
}

